#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// D3Q19 lattice - 19 velocity directions
// Stored as 19 floats per cell: f0, f1, ..., f18

layout(std430, binding = 2) buffer LBMBuffer {
    float f[];  // Distribution functions: size = 19 * gridX * gridY * gridZ
};

layout(std430, binding = 3) buffer LBMBufferNew {
    float f_new[];  // Output buffer for streaming
};

layout(std430, binding = 4) buffer VelocityField {
    vec4 velocity[];  // xyz = velocity, w = density (for particles to sample)
};

layout(std430, binding = 5) buffer SolidMask {
    int solid[];  // 1 = solid (car), 0 = fluid
};

uniform ivec3 gridSize;
uniform float tau;  // Relaxation time (viscosity related)
uniform vec3 inletVelocity;

// D3Q19 lattice velocities
const ivec3 e[19] = ivec3[19](
    ivec3( 0,  0,  0),  // 0: rest
    ivec3( 1,  0,  0),  // 1: +x
    ivec3(-1,  0,  0),  // 2: -x
    ivec3( 0,  1,  0),  // 3: +y
    ivec3( 0, -1,  0),  // 4: -y
    ivec3( 0,  0,  1),  // 5: +z
    ivec3( 0,  0, -1),  // 6: -z
    ivec3( 1,  1,  0),  // 7
    ivec3(-1,  1,  0),  // 8
    ivec3( 1, -1,  0),  // 9
    ivec3(-1, -1,  0),  // 10
    ivec3( 1,  0,  1),  // 11
    ivec3(-1,  0,  1),  // 12
    ivec3( 1,  0, -1),  // 13
    ivec3(-1,  0, -1),  // 14
    ivec3( 0,  1,  1),  // 15
    ivec3( 0, -1,  1),  // 16
    ivec3( 0,  1, -1),  // 17
    ivec3( 0, -1, -1)   // 18
);

// D3Q19 weights
const float w[19] = float[19](
    1.0/3.0,   // rest
    1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0, 1.0/18.0,  // face neighbors
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0,  // edge neighbors
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0,
    1.0/36.0, 1.0/36.0, 1.0/36.0, 1.0/36.0
);

// Opposite direction indices for bounce-back
const int opposite[19] = int[19](
    0, 2, 1, 4, 3, 6, 5,
    10, 9, 8, 7,
    14, 13, 12, 11,
    18, 17, 16, 15
);

int idx3D(int x, int y, int z) {
    return x + y * gridSize.x + z * gridSize.x * gridSize.y;
}

int idxF(int x, int y, int z, int i) {
    return i + 19 * idx3D(x, y, z);
}

// Equilibrium distribution
float feq(int i, float rho, vec3 u) {
    float eu = float(e[i].x) * u.x + float(e[i].y) * u.y + float(e[i].z) * u.z;
    float u2 = dot(u, u);
    float cs2 = 1.0 / 3.0;  // Speed of sound squared
    
    return w[i] * rho * (1.0 + eu/cs2 + (eu*eu)/(2.0*cs2*cs2) - u2/(2.0*cs2));
}

void main() {
    ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);
    
    if (pos.x >= gridSize.x || pos.y >= gridSize.y || pos.z >= gridSize.z) return;
    
    int cellIdx = idx3D(pos.x, pos.y, pos.z);
    
    // Check if this is a solid cell (car)
    if (solid[cellIdx] == 1) {
        // Bounce-back: reverse directions
        for (int i = 0; i < 19; i++) {
            f_new[idxF(pos.x, pos.y, pos.z, i)] = f[idxF(pos.x, pos.y, pos.z, opposite[i])];
        }
        velocity[cellIdx] = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Inlet boundary (left side)
    if (pos.x == 0) {
        float rho = 1.0;
        for (int i = 0; i < 19; i++) {
            f[idxF(pos.x, pos.y, pos.z, i)] = feq(i, rho, inletVelocity);
        }
    }
    
    // Outlet boundary (right side) - zero gradient
    if (pos.x == gridSize.x - 1) {
        for (int i = 0; i < 19; i++) {
            f[idxF(pos.x, pos.y, pos.z, i)] = f[idxF(pos.x - 1, pos.y, pos.z, i)];
        }
    }
    
    // Compute macroscopic quantities
    float rho = 0.0;
    vec3 u = vec3(0.0);
    
    for (int i = 0; i < 19; i++) {
        float fi = f[idxF(pos.x, pos.y, pos.z, i)];
        rho += fi;
        u.x += float(e[i].x) * fi;
        u.y += float(e[i].y) * fi;
        u.z += float(e[i].z) * fi;
    }
    
    if (rho > 0.0001) {
        u /= rho;
    }
    
    // Store velocity for particle advection
    velocity[cellIdx] = vec4(u, rho);
    
    // BGK collision
    float omega = 1.0 / tau;
    
    for (int i = 0; i < 19; i++) {
        float fi = f[idxF(pos.x, pos.y, pos.z, i)];
        float fi_eq = feq(i, rho, u);
        f_new[idxF(pos.x, pos.y, pos.z, i)] = fi - omega * (fi - fi_eq);
    }
}
