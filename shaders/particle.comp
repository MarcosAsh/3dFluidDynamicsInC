#version 430 core
layout(local_size_x = 256) in;

struct Particle {
    vec3 position;
    float padding1;
    vec3 velocity;
    float life;
};

struct Triangle {
    vec3 v0;
    float pad0;
    vec3 v1;
    float pad1;
    vec3 v2;
    float pad2;
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer TriangleBuffer {
    Triangle triangles[];
};

layout(std430, binding = 4) buffer VelocityField {
    vec4 lbmVelocity[];
};

uniform float dt;
uniform vec3 wind;
uniform vec3 carMin;
uniform vec3 carMax;
uniform vec3 carCenter;
uniform int numTriangles;
uniform int collisionMode;

uniform int useLBM;
uniform ivec3 lbmGridSize;

vec3 sampleLBMVelocity(vec3 worldPos) {
    vec3 gridPos;
    gridPos.x = (worldPos.x + 4.0) / 8.0 * float(lbmGridSize.x);
    gridPos.y = (worldPos.y + 2.0) / 4.0 * float(lbmGridSize.y);
    gridPos.z = (worldPos.z + 2.0) / 4.0 * float(lbmGridSize.z);
    
    gridPos = clamp(gridPos, vec3(0.5), vec3(lbmGridSize) - vec3(1.5));
    
    ivec3 cell = ivec3(floor(gridPos));
    cell = clamp(cell, ivec3(0), lbmGridSize - ivec3(1));
    
    int idx = cell.x + cell.y * lbmGridSize.x + cell.z * lbmGridSize.x * lbmGridSize.y;
    
    int maxIdx = lbmGridSize.x * lbmGridSize.y * lbmGridSize.z - 1;
    idx = clamp(idx, 0, maxIdx);
    
    return lbmVelocity[idx].xyz;
}

bool isInsideAABB(vec3 pos, vec3 minB, vec3 maxB) {
    return pos.x >= minB.x && pos.x <= maxB.x &&
           pos.y >= minB.y && pos.y <= maxB.y &&
           pos.z >= minB.z && pos.z <= maxB.z;
}

vec3 getAABBNormal(vec3 pos, vec3 minB, vec3 maxB, vec3 center) {
    vec3 toParticle = pos - center;
    vec3 absDir = abs(toParticle);
    vec3 halfSize = (maxB - minB) * 0.5;
    
    vec3 normal = vec3(0.0);
    if (absDir.x / halfSize.x > absDir.y / halfSize.y && 
        absDir.x / halfSize.x > absDir.z / halfSize.z) {
        normal.x = sign(toParticle.x);
    } else if (absDir.y / halfSize.y > absDir.z / halfSize.z) {
        normal.y = sign(toParticle.y);
    } else {
        normal.z = sign(toParticle.z);
    }
    return normal;
}

vec3 pushOutOfAABB(vec3 pos, vec3 minB, vec3 maxB) {
    vec3 center = (minB + maxB) * 0.5;
    vec3 halfSize = (maxB - minB) * 0.5;
    vec3 toParticle = pos - center;
    
    vec3 penetration;
    penetration.x = halfSize.x - abs(toParticle.x);
    penetration.y = halfSize.y - abs(toParticle.y);
    penetration.z = halfSize.z - abs(toParticle.z);
    
    if (penetration.x < penetration.y && penetration.x < penetration.z) {
        pos.x = center.x + sign(toParticle.x) * (halfSize.x + 0.01);
    } else if (penetration.y < penetration.z) {
        pos.y = center.y + sign(toParticle.y) * (halfSize.y + 0.01);
    } else {
        pos.z = center.z + sign(toParticle.z) * (halfSize.z + 0.01);
    }
    return pos;
}

float pointTriangleDistance(vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 closestPoint, out vec3 normal) {
    vec3 edge0 = v1 - v0;
    vec3 edge1 = v2 - v0;
    vec3 v0p = v0 - p;
    
    float a = dot(edge0, edge0);
    float b = dot(edge0, edge1);
    float c = dot(edge1, edge1);
    float d = dot(edge0, v0p);
    float e = dot(edge1, v0p);
    
    float det = a * c - b * b;
    float s = b * e - c * d;
    float t = b * d - a * e;
    
    if (s + t <= det) {
        if (s < 0.0) {
            if (t < 0.0) {
                if (d < 0.0) { t = 0.0; s = clamp(-d / a, 0.0, 1.0); }
                else { s = 0.0; t = clamp(-e / c, 0.0, 1.0); }
            } else {
                s = 0.0; t = clamp(-e / c, 0.0, 1.0);
            }
        } else if (t < 0.0) {
            t = 0.0; s = clamp(-d / a, 0.0, 1.0);
        } else {
            float invDet = 1.0 / det;
            s *= invDet; t *= invDet;
        }
    } else {
        if (s < 0.0) {
            float tmp0 = b + d, tmp1 = c + e;
            if (tmp1 > tmp0) {
                float numer = tmp1 - tmp0;
                s = clamp(numer / (a - 2.0 * b + c), 0.0, 1.0);
                t = 1.0 - s;
            } else { s = 0.0; t = clamp(-e / c, 0.0, 1.0); }
        } else if (t < 0.0) {
            float tmp0 = b + e, tmp1 = a + d;
            if (tmp1 > tmp0) {
                float numer = tmp1 - tmp0;
                t = clamp(numer / (a - 2.0 * b + c), 0.0, 1.0);
                s = 1.0 - t;
            } else { t = 0.0; s = clamp(-d / a, 0.0, 1.0); }
        } else {
            float numer = (c + e) - (b + d);
            s = clamp(numer / (a - 2.0 * b + c), 0.0, 1.0);
            t = 1.0 - s;
        }
    }
    
    closestPoint = v0 + s * edge0 + t * edge1;
    normal = normalize(cross(edge0, edge1));
    return length(p - closestPoint);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= particles.length()) return;
    
    Particle p = particles[idx];
    
    vec3 flowVel;
    if (useLBM == 1 && lbmGridSize.x > 0) {
        flowVel = sampleLBMVelocity(p.position) * 15.0;
    } else {
        flowVel = wind;
    }
    
    p.velocity = flowVel;
    p.position += p.velocity * dt;
    
    if (collisionMode == 1) {
        if (isInsideAABB(p.position, carMin, carMax)) {
            vec3 normal = getAABBNormal(p.position, carMin, carMax, carCenter);
            p.position = pushOutOfAABB(p.position, carMin, carMax);
            
            float velDotNormal = dot(p.velocity, normal);
            if (velDotNormal < 0.0) {
                p.velocity = p.velocity - 1.5 * velDotNormal * normal;
                p.velocity.y += (fract(sin(float(idx) * 12.9898) * 43758.5453) - 0.5) * 0.2;
                p.velocity.z += (fract(sin(float(idx) * 78.233) * 43758.5453) - 0.5) * 0.2;
            }
        }
    }
    else if (collisionMode == 2 && numTriangles > 0) {
        float collisionRadius = 0.05;
        
        for (int i = 0; i < numTriangles; i++) {
            Triangle tri = triangles[i];
            vec3 closestPoint, normal;
            float dist = pointTriangleDistance(p.position, tri.v0, tri.v1, tri.v2, closestPoint, normal);
            
            if (dist < collisionRadius) {
                p.position = closestPoint + normal * collisionRadius;
                
                float velDotNormal = dot(p.velocity, normal);
                if (velDotNormal < 0.0) {
                    p.velocity = p.velocity - 1.5 * velDotNormal * normal;
                    p.velocity.y += (fract(sin(float(idx) * 12.9898) * 43758.5453) - 0.5) * 0.2;
                    p.velocity.z += (fract(sin(float(idx) * 78.233) * 43758.5453) - 0.5) * 0.2;
                }
                break;
            }
        }
    }
    
    p.life -= 0.01 * dt;
    
    if (p.life <= 0.0 || p.position.x > 4.0) {
        p.position = vec3(-4.0, 
                         (fract(sin(float(idx) * 43758.5453)) - 0.5) * 3.0, 
                         (fract(sin(float(idx) * 12345.6789)) - 0.5) * 3.0);
        p.velocity = vec3(0.5 + fract(sin(float(idx) * 9876.54321)) * 0.2, 0.0, 0.0);
        p.life = 1.0;
    }
    
    if (p.position.y < -2.0 || p.position.y > 2.0) {
        p.velocity.y *= -0.5;
        p.position.y = clamp(p.position.y, -2.0, 2.0);
    }
    if (p.position.z < -2.0 || p.position.z > 2.0) {
        p.velocity.z *= -0.5;
        p.position.z = clamp(p.position.z, -2.0, 2.0);
    }
    
    particles[idx] = p;
}